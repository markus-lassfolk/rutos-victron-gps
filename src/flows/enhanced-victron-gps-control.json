[
  {
    "id": "052a8592cc8aee65",
    "type": "tab",
    "label": "Enhanced Victron GPS Control",
    "disabled": false,
    "info": "Enhanced GPS flow with:\n- Data-driven thresholds (RUTOS: 1m, Starlink: 7m, Position: 6m, Altitude: 18m)\n- Always-use-most-accurate GPS source selection\n- Smart movement detection with Haversine distance calculations\n- Enhanced error handling with fallback logic\n- Manual override system\n- File logging with accuracy tracking\n- GPS stability monitoring (6m threshold)"
  },
  {
    "id": "86830d0a0f296f20",
    "type": "inject",
    "z": "052a8592cc8aee65",
    "name": "Initialize Config",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "init",
    "payloadType": "str",
    "x": 130,
    "y": 580,
    "wires": [
      [
        "627f8ecb9fecbb11"
      ]
    ]
  },
  {
    "id": "627f8ecb9fecbb11",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Configuration Manager",
    "func": "// Configuration Manager - Centralized parameter management\n\nif (msg.topic === 'config/set' && msg.payload.param && msg.payload.value !== undefined) {\n    // Set configuration parameter\n    flow.set(msg.payload.param, msg.payload.value);\n    node.status({fill: 'green', shape: 'dot', text: `Set ${msg.payload.param}: ${msg.payload.value}`});\n    return {topic: 'config/updated', payload: {param: msg.payload.param, value: msg.payload.value}};\n}\n\nif (msg.topic === 'config/get') {\n    // Get all configuration parameters\n    const config = {\n        rutos_accuracy: flow.get('config_rutos_accuracy') || 1,        // Data-driven: 1m (2x degradation from 0.5m typical)\n        starlink_accuracy: flow.get('config_starlink_accuracy') || 7,  // Data-driven: 7m (avg 5.5m + buffer)\n        position_eps: flow.get('config_position_eps') || 6,            // Data-driven: 6m (max observed 5.2m + buffer)\n        altitude_threshold: flow.get('config_altitude_threshold') || 18, // Data-driven: 18m (p95 15.4m + buffer)\n        speed_threshold: flow.get('config_speed_threshold') || 0.1,\n        camping_threshold: flow.get('config_camping_threshold') || 50,\n        obstruction_threshold: flow.get('config_obstruction_threshold') || 200,\n        gps_stability_threshold: flow.get('config_gps_stability_threshold') || 6, // Data-driven: 6m (max jitter 4.7m + buffer)\n        stationary_time: flow.get('config_stationary_time') || 300000,\n        source_override: flow.get('config_source_override') || 'auto',\n        log_level: flow.get('config_log_level') || 'info'\n    };\n    return {topic: 'config/current', payload: config};\n}\n\n// Initialize default configuration on startup\nif (msg.payload === 'init') {\n    const defaults = {\n        config_rutos_accuracy: 1,        // Data-driven: 1m (2x degradation from 0.5m typical)\n        config_starlink_accuracy: 7,     // Data-driven: 7m (avg 5.5m + buffer)\n        config_position_eps: 6,          // Data-driven: 6m (max observed 5.2m + buffer)\n        config_altitude_threshold: 18,   // Data-driven: 18m (p95 15.4m + buffer)\n        config_speed_threshold: 0.1,\n        config_camping_threshold: 50,\n        config_obstruction_threshold: 200,\n        config_gps_stability_threshold: 6, // Data-driven: 6m (max jitter 4.7m + buffer)\n        config_stationary_time: 300000,\n        config_source_override: 'auto',\n        config_log_level: 'info'\n    };\n    \n    Object.keys(defaults).forEach(key => {\n        if (flow.get(key) === undefined) {\n            flow.set(key, defaults[key]);\n        }\n    });\n    \n    node.status({fill: 'blue', shape: 'dot', text: 'Config initialized'});\n    return {topic: 'config/initialized', payload: defaults};\n}\n\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 340,
    "y": 580,
    "wires": [
      [
        "e083d8d49c69bec7"
      ]
    ]
  },
  {
    "id": "e083d8d49c69bec7",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Config Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "x": 580,
    "y": 580,
    "wires": []
  },
  {
    "id": "556c1786c42170d2",
    "type": "mqtt in",
    "z": "052a8592cc8aee65",
    "name": "Manual Override",
    "topic": "gps/control/+",
    "qos": "2",
    "datatype": "auto-detect",
    "broker": "2712849475d6de23",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 640,
    "wires": [
      [
        "c4ea4dad0edad6ed"
      ]
    ]
  },
  {
    "id": "c4ea4dad0edad6ed",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Override Handler",
    "func": "// Manual Override Handler\n// MQTT Topics:\n// gps/control/source - Set source override: 'auto', 'rutos', 'starlink'\n// gps/control/force_update - Force GPS update regardless of change detection\n// gps/control/reset_obstruction - Force obstruction map reset\n// gps/control/config - Set configuration parameters\n\nconst parts = msg.topic.split('/');\nconst command = parts[2];\n\nswitch (command) {\n    case 'source':\n        if (['auto', 'rutos', 'starlink'].includes(msg.payload)) {\n            flow.set('config_source_override', msg.payload);\n            node.status({fill: 'yellow', shape: 'dot', text: `Source: ${msg.payload}`});\n            return {topic: 'gps/status', payload: {command: 'source_override', value: msg.payload}};\n        }\n        break;\n        \n    case 'force_update':\n        if (msg.payload === true || msg.payload === 'true') {\n            flow.set('force_next_update', true);\n            node.status({fill: 'orange', shape: 'dot', text: 'Force update set'});\n            return {topic: 'gps/status', payload: {command: 'force_update', value: true}};\n        }\n        break;\n        \n    case 'reset_obstruction':\n        if (msg.payload === true || msg.payload === 'true') {\n            return [null, {topic: 'gps/control/obstruction_reset', payload: {forced: true}}];\n        }\n        break;\n        \n    case 'config':\n        try {\n            const config = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n            if (config.param && config.value !== undefined) {\n                flow.set(`config_${config.param}`, config.value);\n                node.status({fill: 'green', shape: 'dot', text: `Config: ${config.param}`});\n                return {topic: 'gps/status', payload: {command: 'config_set', param: config.param, value: config.value}};\n            }\n        } catch (e) {\n            node.error('Invalid config JSON: ' + e.message);\n        }\n        break;\n        \n    case 'get_logs':\n        const logs = flow.get('event_logs') || [];\n        return {topic: 'gps/logs', payload: logs};\n        \n    case 'get_status':\n        const status = {\n            last_position: flow.get('last_position'),\n            victron_stored: flow.get('victron_stored_position'),\n            source_override: flow.get('config_source_override'),\n            last_update: flow.get('last_victron_update')\n        };\n        return {topic: 'gps/status', payload: status};\n        \n    case 'get_accuracy_stats':\n        // Get accuracy statistics for both sources\n        const rutosStats = flow.get('rutos_accuracy_stats') || {readings: [], avg: 0, count: 0};\n        const starlinkStats = flow.get('starlink_accuracy_stats') || {readings: [], avg: 0, count: 0};\n        \n        const stats = {\n            rutos: {\n                count: rutosStats.count,\n                average: rutosStats.avg,\n                moving_avg: rutosStats.readings.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, rutosStats.readings.length) || 0,\n                min: Math.min(...rutosStats.readings) || 0,\n                max: Math.max(...rutosStats.readings) || 0,\n                recommended_threshold: Math.ceil((rutosStats.avg || 5) * 1.5)\n            },\n            starlink: {\n                count: starlinkStats.count,\n                average: starlinkStats.avg,\n                moving_avg: starlinkStats.readings.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, starlinkStats.readings.length) || 0,\n                min: Math.min(...starlinkStats.readings) || 0,\n                max: Math.max(...starlinkStats.readings) || 0,\n                recommended_threshold: Math.ceil((starlinkStats.avg || 10) * 1.5)\n            }\n        };\n        return {topic: 'gps/accuracy_stats', payload: stats};\n}\n\nreturn null;",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 690,
    "y": 640,
    "wires": [
      [
        "d969086d9708320e",
        "8230b22fdf7aeb05"
      ],
      [
        "bdb24cd84e9befd5"
      ]
    ]
  },
  {
    "id": "d969086d9708320e",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Override Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "x": 660,
    "y": 720,
    "wires": []
  },
  {
    "id": "31e3929429ac8625",
    "type": "mqtt in",
    "z": "052a8592cc8aee65",
    "name": "Read Victron GPS",
    "topic": "R/+/gps/+/Position/+",
    "qos": "2",
    "datatype": "auto-detect",
    "broker": "2712849475d6de23",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 150,
    "y": 740,
    "wires": [
      [
        "248189ee15d89297"
      ]
    ]
  },
  {
    "id": "248189ee15d89297",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Parse Victron GPS",
    "func": "// Parse Victron GPS readings to maintain stored position cache\n\nconst parts = msg.topic.split('/');\nif (parts.length < 6) return null;\n\nconst portal = parts[1];\nconst device = parts[3];\nconst field = parts[5]; // Latitude or Longitude\n\nlet stored = flow.get('victron_stored_position') || {};\n\ntry {\n    const data = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n    const value = data.value;\n    \n    if (field === 'Latitude') {\n        stored.lat = +value;\n    } else if (field === 'Longitude') {\n        stored.lon = +value;\n    }\n    \n    stored.portal = portal;\n    stored.device = device;\n    stored.updated = Date.now();\n    \n    flow.set('victron_stored_position', stored);\n    \n    return {\n        topic: 'victron/position/updated',\n        payload: {\n            field: field,\n            value: value,\n            stored: stored\n        }\n    };\n} catch (e) {\n    node.error('Error parsing Victron GPS: ' + e.message);\n    return null;\n}",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 290,
    "y": 880,
    "wires": [
      [
        "1791ba49815191e7"
      ]
    ]
  },
  {
    "id": "1791ba49815191e7",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Victron GPS Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "x": 510,
    "y": 820,
    "wires": []
  },
  {
    "id": "8230b22fdf7aeb05",
    "type": "mqtt out",
    "z": "052a8592cc8aee65",
    "name": "Status/Logs Output",
    "topic": "",
    "qos": "",
    "retain": "",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "2712849475d6de23",
    "x": 850,
    "y": 560,
    "wires": []
  },
  {
    "id": "3a90bc39e6b61d2a",
    "type": "file",
    "z": "052a8592cc8aee65",
    "name": "GPS Event Log",
    "filename": "/tmp/gps-events.log",
    "appendNewline": true,
    "createDir": false,
    "overwriteFile": "false",
    "encoding": "none",
    "x": 1300,
    "y": 760,
    "wires": [
      []
    ]
  },
  {
    "id": "fe51d2b0069aee89",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Log Formatter",
    "func": "// Format log entries for file output\n\nif (msg.topic === 'gps/log' && msg.payload) {\n    const logLevel = flow.get('config_log_level') || 'info';\n    const levels = {debug: 0, info: 1, warn: 2, error: 3};\n    \n    const msgLevel = levels[msg.payload.level] || 1;\n    const configLevel = levels[logLevel] || 1;\n    \n    // Only log if message level is >= configured level\n    if (msgLevel >= configLevel) {\n        const formatted = JSON.stringify(msg.payload);\n        return {payload: formatted};\n    }\n}\n\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1240,
    "y": 660,
    "wires": [
      [
        "3a90bc39e6b61d2a"
      ]
    ]
  },
  {
    "id": "8c42f9e4b72479ac",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Enhanced Error Handler",
    "func": "// Enhanced Error Handler with retry logic and fallback\n\nconst errorSource = msg.errorSource || 'unknown';\nconst errorMsg = msg.payload || 'Unknown error';\nconst now = Date.now();\n\n// Track error counts\nlet errorCounts = flow.get('error_counts') || {};\nerrorCounts[errorSource] = (errorCounts[errorSource] || 0) + 1;\nflow.set('error_counts', errorCounts);\n\n// Log the error\nconst logEntry = {\n    ts: new Date().toISOString(),\n    level: 'error',\n    event: 'error_occurred',\n    data: {\n        source: errorSource,\n        message: errorMsg,\n        count: errorCounts[errorSource],\n        raw: msg\n    }\n};\n\n// Store in event logs\nlet logs = flow.get('event_logs') || [];\nlogs.push(logEntry);\nif (logs.length > 100) logs = logs.slice(-100);\nflow.set('event_logs', logs);\n\n// Determine if we should implement fallback behavior\nif (errorSource === 'starlink' && errorCounts.starlink > 3) {\n    // Too many Starlink errors, prefer RUTOS\n    flow.set('starlink_degraded', true);\n    flow.set('starlink_degraded_until', now + 600000); // 10 minutes\n} else if (errorSource === 'rutos' && errorCounts.rutos > 3) {\n    // Too many RUTOS errors, prefer Starlink\n    flow.set('rutos_degraded', true);\n    flow.set('rutos_degraded_until', now + 600000); // 10 minutes\n}\n\n// Reset error counts periodically\nif (!flow.get('error_reset_timer')) {\n    flow.set('error_reset_timer', now);\n} else if (now - flow.get('error_reset_timer') > 3600000) { // 1 hour\n    flow.set('error_counts', {});\n    flow.set('error_reset_timer', now);\n}\n\nreturn [\n    {topic: 'gps/log', payload: logEntry},\n    {topic: 'gps/error', payload: {source: errorSource, message: errorMsg, count: errorCounts[errorSource]}}\n];",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1010,
    "y": 500,
    "wires": [
      [
        "fe51d2b0069aee89"
      ],
      [
        "4bc9c9df5144215e"
      ]
    ]
  },
  {
    "id": "4bc9c9df5144215e",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Error Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "x": 710,
    "y": 960,
    "wires": []
  },
  {
    "id": "c380db185b9d6095",
    "type": "mqtt in",
    "z": "052a8592cc8aee65",
    "name": "IDs listener",
    "topic": "device/+/DBus",
    "qos": "2",
    "datatype": "auto-detect",
    "broker": "2712849475d6de23",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 40,
    "wires": [
      [
        "3208ed25342a77e9"
      ]
    ]
  },
  {
    "id": "3208ed25342a77e9",
    "type": "json",
    "z": "052a8592cc8aee65",
    "name": "",
    "property": "payload",
    "action": "",
    "pretty": false,
    "x": 300,
    "y": 40,
    "wires": [
      [
        "25cedf93982c9bf7"
      ]
    ]
  },
  {
    "id": "8c394714af33f7e8",
    "type": "inject",
    "z": "052a8592cc8aee65",
    "name": "Every 30 min",
    "props": [],
    "repeat": "1800",
    "crontab": "",
    "once": true,
    "onceDelay": "1",
    "topic": "",
    "x": 130,
    "y": 180,
    "wires": [
      [
        "2dd537dd208339ef"
      ]
    ]
  },
  {
    "id": "2dd537dd208339ef",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Trigger Branches",
    "func": "// TODO: Replace with your actual RUTOS credentials\n// For security, consider using environment variables or Node-RED credentials\nreturn [{payload:\"go\"},{payload:{username:\"admin\",password:\"YOUR_RUTOS_PASSWORD_HERE\"}}];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 330,
    "y": 180,
    "wires": [
      [
        "10a3a2c7e202183f"
      ],
      [
        "f236b706a467f934"
      ]
    ]
  },
  {
    "id": "10a3a2c7e202183f",
    "type": "exec",
    "z": "052a8592cc8aee65",
    "command": "/data/bin/grpcurl -plaintext -emit-defaults -d '{\"get_diagnostics\":{}}' 192.168.100.1:9200 SpaceX.API.Device.Device/Handle",
    "addpay": false,
    "append": "",
    "useSpawn": "false",
    "timer": "10",
    "winHide": false,
    "oldrc": false,
    "name": "Get Starlink GPS",
    "x": 570,
    "y": 140,
    "wires": [
      [
        "84975868aa8b14d8"
      ],
      [
        "74fe6fa9c30dbbfa"
      ],
      []
    ]
  },
  {
    "id": "84975868aa8b14d8",
    "type": "json",
    "z": "052a8592cc8aee65",
    "name": "",
    "property": "payload",
    "action": "",
    "pretty": false,
    "x": 750,
    "y": 120,
    "wires": [
      [
        "de57523fd724719b"
      ]
    ]
  },
  {
    "id": "de57523fd724719b",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Format Starlink GPS",
    "func": "msg.topic = \"starlink\";\n\nvar diag = msg.payload && msg.payload.dishGetDiagnostics;\nif (!diag || !diag.location) {\n    // Send error to error handler\n    node.send([null, {errorSource: 'starlink', payload: 'No diagnostics or location data'}]);\n    return null;\n}\n\nvar loc = diag.location;\nif (loc.latitude == null || loc.longitude == null || loc.altitudeMeters == null) {\n    node.send([null, {errorSource: 'starlink', payload: 'Missing coordinate data'}]);\n    return null;\n}\n\nvar o = {\n    lat   : +loc.latitude,\n    lon   : +loc.longitude,\n    alt   : +loc.altitudeMeters,\n    gpsFix: loc.uncertaintyMetersValid ? 1 : 0\n};\nif (loc.uncertaintyMetersValid && loc.uncertaintyMeters != null) {\n    o.hAcc = +loc.uncertaintyMeters;      // horizontal accuracy (m)\n}\nmsg.payload = o;\nreturn [msg, null];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 960,
    "y": 120,
    "wires": [
      [
        "2b5e76c5eb2dce12",
        "e7d0663bcdd44a06"
      ],
      [
        "8c42f9e4b72479ac"
      ]
    ]
  },
  {
    "id": "74fe6fa9c30dbbfa",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Starlink fail",
    "func": "msg.topic=\"starlink\";\nmsg.payload=null;\n\n// Send to error handler\nnode.send([msg, {errorSource: 'starlink', payload: 'gRPC command failed: ' + JSON.stringify(msg)}]);\n\nreturn [msg, null];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 180,
    "wires": [
      [
        "2b5e76c5eb2dce12"
      ],
      [
        "8c42f9e4b72479ac"
      ]
    ]
  },
  {
    "id": "f236b706a467f934",
    "type": "http request",
    "z": "052a8592cc8aee65",
    "name": "RUTOS login",
    "method": "POST",
    "ret": "json",
    "paytoqs": "ignore",
    "url": "https://192.168.80.1/api/login",
    "tls": "19c194ce1c405d3a",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [
      {
        "keyType": "other",
        "keyValue": "Content-Type",
        "valueType": "other",
        "valueValue": "application/json"
      }
    ],
    "x": 550,
    "y": 260,
    "wires": [
      [
        "d863193107c568b7"
      ]
    ]
  },
  {
    "id": "d863193107c568b7",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Set auth header",
    "func": "const p=typeof msg.payload==='string'?JSON.parse(msg.payload):msg.payload;\nconst t=p?.data?.token;\nif(!t){\n    // Send to error handler\n    node.send([null, {errorSource: 'rutos', payload: 'No authentication token received'}]);\n    return null;\n}\nmsg.headers={Authorization:`Bearer ${t}`};\nmsg.payload={};\nreturn [msg, null];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 260,
    "wires": [
      [
        "015d60b5aea849b4"
      ],
      [
        "8c42f9e4b72479ac"
      ]
    ]
  },
  {
    "id": "015d60b5aea849b4",
    "type": "http request",
    "z": "052a8592cc8aee65",
    "name": "Get RUTOS GPS",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "https://192.168.80.1/api/gps/position/status",
    "tls": "19c194ce1c405d3a",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 570,
    "y": 340,
    "wires": [
      [
        "fd3b972f28865fea",
        "1ab986af44cca762"
      ]
    ]
  },
  {
    "id": "fd3b972f28865fea",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Format RUTOS GPS",
    "func": "msg.topic = \"rutos\";\n\nvar d = msg.payload && msg.payload.data;\nif (!d) {\n    node.send([null, {errorSource: 'rutos', payload: 'No GPS data received'}]);\n    return null;\n}\n\nvar fix = parseInt(d.fix_status, 10) || 0;\nif (d.latitude == null || d.longitude == null || d.altitude == null) {\n    node.send([null, {errorSource: 'rutos', payload: 'Missing coordinate data'}]);\n    return null;\n}\n\nvar o = {\n    lat   : +d.latitude,\n    lon   : +d.longitude,\n    alt   : +d.altitude,\n    gpsFix: fix\n};\n\nif (d.satellites != null) o.sats = +d.satellites;   // satellite count\nif (d.accuracy  != null) o.hAcc = +d.accuracy;      // HDOP (m)\nif (d.speed     != null) {\n    var s = +d.speed;                               // km / h\n    if (!isNaN(s)) o.speed = s * 0.277777778;       // â†’ m / s\n}\nmsg.payload = o;\nreturn [msg, null];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 340,
    "wires": [
      [
        "2b5e76c5eb2dce12",
        "e3dff9260e2223fb"
      ],
      [
        "8c42f9e4b72479ac"
      ]
    ]
  },
  {
    "id": "2b5e76c5eb2dce12",
    "type": "join",
    "z": "052a8592cc8aee65",
    "name": "Combine GPS",
    "mode": "custom",
    "build": "object",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "joinerType": "str",
    "accumulate": false,
    "timeout": "15",
    "count": "2",
    "reduceRight": false,
    "x": 1200,
    "y": 180,
    "wires": [
      [
        "fb3f6f8d9478837a",
        "7a40dacb6ed111fe"
      ]
    ]
  },
  {
    "id": "fb3f6f8d9478837a",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Enhanced GPS Logic",
    "func": "// Enhanced GPS Processing with configurable thresholds and smart movement logic\n\n// ===== UTILITY FUNCTIONS =====\nfunction hav(p1, p2) {\n    const R = 6371000, rad = Math.PI / 180;\n    const dLat = (p2.lat - p1.lat) * rad, dLon = (p2.lon - p1.lon) * rad;\n    const lat1 = p1.lat * rad, lat2 = p2.lat * rad;\n    const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;\n    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\nfunction logEvent(level, event, data) {\n    const logEntry = {\n        ts: new Date().toISOString(),\n        level: level,\n        event: event,\n        data: data\n    };\n    \n    // Store recent logs in flow context (last 100 entries)\n    let logs = flow.get('event_logs') || [];\n    logs.push(logEntry);\n    if (logs.length > 100) logs = logs.slice(-100);\n    flow.set('event_logs', logs);\n    \n    // Send to logging output (4th output)\n    node.send([null, null, null, { payload: logEntry, topic: 'gps/log' }]);\n}\n\n// ===== CONFIGURABLE PARAMETERS =====\nconst config = {\n    // GPS quality thresholds - Updated with data-driven values\n    rutosAccuracyThreshold: flow.get('config_rutos_accuracy') || 1,        // Data-driven: 1m (2x degradation from 0.5m typical)\n    starlinkAccuracyThreshold: flow.get('config_starlink_accuracy') || 7,  // Data-driven: 7m (avg 5.5m + buffer)\n    \n    // Change detection thresholds - Updated with data-driven values\n    positionEpsilon: flow.get('config_position_eps') || 6,                 // Data-driven: 6m (max observed 5.2m + buffer)\n    altitudeThreshold: flow.get('config_altitude_threshold') || 18,        // Data-driven: 18m (p95 15.4m + buffer)\n    speedThreshold: flow.get('config_speed_threshold') || 0.1,             // km/h\n    \n    // Movement detection\n    campingMoveThreshold: flow.get('config_camping_threshold') || 50,      // meters\n    resetObstructionThreshold: flow.get('config_obstruction_threshold') || 200, // meters\n    stationaryTimeThreshold: flow.get('config_stationary_time') || 300000, // 5 min in ms\n    gpsStabilityThreshold: flow.get('config_gps_stability_threshold') || 6, // Data-driven: 6m (max jitter 4.7m + buffer)\n    \n    // Source override\n    sourceOverride: flow.get('config_source_override') || 'auto'          // 'auto', 'rutos', 'starlink'\n};\n\n// ===== DATA PREPARATION =====\nconst star = msg.payload.starlink || {};\nconst rut = msg.payload.rutos || {};\nconst last = flow.get('last_position') || {};\nconst victronStored = flow.get('victron_stored_position') || {};\nconst now = Date.now();\nconst forceUpdate = flow.get('force_next_update');\n\nlogEvent('debug', 'gps_processing_start', { star: !!star.lat, rutos: !!rut.lat, override: config.sourceOverride, force: !!forceUpdate });\n\n// Check for degraded sources\nconst starlinkDegraded = flow.get('starlink_degraded') && now < (flow.get('starlink_degraded_until') || 0);\nconst rutosDegraded = flow.get('rutos_degraded') && now < (flow.get('rutos_degraded_until') || 0);\n\n// ===== SOURCE SELECTION WITH OVERRIDE =====\nlet src, srcData;\n\n// Manual override logic\nif (config.sourceOverride === 'rutos' && rut.gpsFix > 0 && !rutosDegraded) {\n    src = 'rutos';\n    srcData = rut;\n    logEvent('info', 'source_override_rutos', rut);\n} else if (config.sourceOverride === 'starlink' && star.gpsFix > 0 && !starlinkDegraded) {\n    src = 'starlink';\n    srcData = star;\n    logEvent('info', 'source_override_starlink', star);\n} else {\n    // Automatic source selection with configurable thresholds and degradation awareness\n    const goodRut = rut.gpsFix > 0 && Number.isFinite(rut.hAcc) && rut.hAcc < config.rutosAccuracyThreshold && !rutosDegraded;\n    const goodStar = star.gpsFix > 0 && Number.isFinite(star.hAcc) && star.hAcc < config.starlinkAccuracyThreshold && !starlinkDegraded;\n    \n    if (goodRut && goodStar) {\n        src = (rut.hAcc <= star.hAcc) ? 'rutos' : 'starlink';\n        srcData = src === 'rutos' ? rut : star;\n        logEvent('info', 'auto_source_best_accuracy', { selected: src, rutosAcc: rut.hAcc, starlinkAcc: star.hAcc });\n    } else if (goodRut) {\n        src = 'rutos';\n        srcData = rut;\n        logEvent('info', 'auto_source_rutos_only', rut);\n    } else if (goodStar) {\n        src = 'starlink'; \n        srcData = star;\n        logEvent('info', 'auto_source_starlink_only', star);\n    } else {\n        // Fallback to last known position with degraded accuracy\n        if (last.lat && last.lon) {\n            logEvent('warn', 'fallback_last_position', { age: now - (last.ts || 0), starlinkDegraded, rutosDegraded });\n            return [\n                {\n                    payload: {\n                        ...last,\n                        gpsFix: 0,\n                        hAcc: 999,\n                        source: 'fallback',\n                        ts: now\n                    }\n                },\n                null, null, null\n            ];\n        }\n        logEvent('error', 'no_gps_sources_available', { rutos: rut, starlink: star, degraded: {starlink: starlinkDegraded, rutos: rutosDegraded} });\n        return null;\n    }\n}\n\n// ===== POSITION PROCESSING =====\nlet c = {\n    lat: srcData.lat,\n    lon: srcData.lon, \n    alt: srcData.alt,\n    gpsFix: srcData.gpsFix,\n    hAcc: srcData.hAcc,\n    sats: srcData.sats,\n    source: src,\n    ts: now\n};\n\n// Speed calculation\nif (Number.isFinite(srcData.speed)) {\n    c.speed = srcData.speed;\n} else if (Number.isFinite(last.lat) && Number.isFinite(last.lon) && last.ts) {\n    const m = hav(last, c);\n    const sec = (now - last.ts) / 1000;\n    c.speed = sec > 0 ? (m / sec) * 3.6 : 0; // km/h\n} else {\n    c.speed = 0;\n}\n\n// ===== MOVEMENT ANALYSIS =====\nconst movedFromLast = Number.isFinite(last.lat) ? hav(last, c) : 0;\nconst movedFromVictron = Number.isFinite(victronStored.lat) ? hav(victronStored, c) : 0;\nconst timeSinceLastMove = last.ts ? now - last.ts : 0;\nconst isStationary = timeSinceLastMove > config.stationaryTimeThreshold && c.speed < 1;\n\nlogEvent('debug', 'movement_analysis', {\n    movedFromLast: movedFromLast.toFixed(1),\n    movedFromVictron: movedFromVictron.toFixed(1),\n    timeSinceLastMove: Math.round(timeSinceLastMove / 1000),\n    isStationary: isStationary,\n    speed: c.speed\n});\n\n// ===== CHANGE DETECTION =====\n// Updated to use distance-based position comparison with data-driven thresholds\nconst posChanged = Number.isFinite(last.lat) && Number.isFinite(last.lon) ? \n                   hav(last, c) > config.positionEpsilon : true;  // Use Haversine distance in meters\nconst altChanged = Math.abs((last.alt || 0) - c.alt) > config.altitudeThreshold;\nconst speedChanged = Math.abs((last.speed || 0) - c.speed) > config.speedThreshold;\nconst changed = posChanged || altChanged || speedChanged || forceUpdate;\n\n// Update stored position\nflow.set('last_position', { ...c, ts: now });\n\n// Clear force update flag\nif (forceUpdate) {\n    flow.set('force_next_update', false);\n    logEvent('info', 'force_update_processed', {});\n}\n\nif (!changed) {\n    logEvent('debug', 'no_significant_change', { posChanged, altChanged, speedChanged });\n    return null;\n}\n\n// ===== OUTPUT LOGIC =====\nlet outputs = [null, null, null, null]; // [update, obstruction_reset, victron_update, log]\n\n// Track accuracy statistics for both sources\nif (src === 'rutos' && Number.isFinite(rut.hAcc)) {\n    let rutosStats = flow.get('rutos_accuracy_stats') || {readings: [], sum: 0, count: 0, avg: 0};\n    rutosStats.readings.push(rut.hAcc);\n    if (rutosStats.readings.length > 100) rutosStats.readings = rutosStats.readings.slice(-100);\n    rutosStats.sum += rut.hAcc;\n    rutosStats.count++;\n    rutosStats.avg = rutosStats.sum / rutosStats.count;\n    flow.set('rutos_accuracy_stats', rutosStats);\n} else if (src === 'starlink' && Number.isFinite(star.hAcc)) {\n    let starlinkStats = flow.get('starlink_accuracy_stats') || {readings: [], sum: 0, count: 0, avg: 0};\n    starlinkStats.readings.push(star.hAcc);\n    if (starlinkStats.readings.length > 100) starlinkStats.readings = starlinkStats.readings.slice(-100);\n    starlinkStats.sum += star.hAcc;\n    starlinkStats.count++;\n    starlinkStats.avg = starlinkStats.sum / starlinkStats.count;\n    flow.set('starlink_accuracy_stats', starlinkStats);\n}\n\n// GPS Stability Monitoring - Track position jitter with data-driven threshold\nlet positionHistory = flow.get(src + '_position_history') || [];\npositionHistory.push({lat: c.lat, lon: c.lon, ts: now});\nif (positionHistory.length > 20) positionHistory = positionHistory.slice(-20); // Keep last 20 positions\nflow.set(src + '_position_history', positionHistory);\n\n// Calculate recent GPS jitter (last 10 positions)\nif (positionHistory.length >= 10) {\n    const recent = positionHistory.slice(-10);\n    const distances = [];\n    for (let i = 1; i < recent.length; i++) {\n        distances.push(hav(recent[i-1], recent[i]));\n    }\n    const maxJitter = Math.max(...distances);\n    const avgJitter = distances.reduce((a, b) => a + b, 0) / distances.length;\n    \n    // Check for GPS instability using data-driven threshold\n    if (maxJitter > config.gpsStabilityThreshold) {\n        logEvent('warn', 'gps_instability_detected', {\n            source: src,\n            maxJitter: maxJitter.toFixed(1),\n            avgJitter: avgJitter.toFixed(1),\n            threshold: config.gpsStabilityThreshold,\n            accuracy: c.hAcc\n        });\n    }\n}\n\n// Always send GPS update (output 1)\noutputs[0] = { payload: c };\n\n// Obstruction map reset logic (output 2)\n// Reset if: moved significantly AND (camping move OR been stationary)\nif (movedFromLast > config.resetObstructionThreshold && \n    (movedFromLast < 1000 || isStationary)) { // < 1km suggests camping, not highway driving\n    \n    logEvent('info', 'obstruction_reset_triggered', {\n        distance: movedFromLast.toFixed(1),\n        reason: movedFromLast < 1000 ? 'camping_move' : 'stationary_then_moved'\n    });\n    \n    outputs[1] = { \n        payload: c, \n        distance: movedFromLast,\n        reason: 'position_change'\n    };\n}\n\n// Victron GPS update logic (output 3)\n// Update if: significant move from stored Victron position OR been 5+ minutes since last Victron update\nconst lastVictronUpdate = flow.get('last_victron_update') || 0;\nconst victronUpdateNeeded = movedFromVictron > config.campingMoveThreshold || \n                           (now - lastVictronUpdate) > 300000; // 5 minutes\n\nif (victronUpdateNeeded || forceUpdate) {\n    logEvent('info', 'victron_update_triggered', {\n        distanceFromStored: movedFromVictron.toFixed(1),\n        timeSinceLastUpdate: Math.round((now - lastVictronUpdate) / 1000),\n        reason: forceUpdate ? 'forced' : (movedFromVictron > config.campingMoveThreshold ? 'position_change' : 'time_based')\n    });\n    \n    flow.set('last_victron_update', now);\n    outputs[2] = { payload: c };\n}\n\nlogEvent('info', 'gps_processing_complete', {\n    source: src,\n    position: `${c.lat.toFixed(6)}, ${c.lon.toFixed(6)}`,\n    accuracy: c.hAcc,\n    outputs: {\n        update: !!outputs[0],\n        obstruction: !!outputs[1], \n        victron: !!outputs[2]\n    }\n});\n\nreturn outputs;",
    "outputs": 4,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1450,
    "y": 180,
    "wires": [
      [
        "df60837fdef6ee90"
      ],
      [
        "abaf331e329a7829",
        "bdb24cd84e9befd5"
      ],
      [
        "5d6237d293375110"
      ],
      [
        "fe51d2b0069aee89"
      ]
    ]
  },
  {
    "id": "d574da3f1115d8ae",
    "type": "mqtt in",
    "z": "052a8592cc8aee65",
    "name": "GPS tap",
    "topic": "W/+/gps/+/+/#",
    "qos": "2",
    "datatype": "auto-detect",
    "broker": "2712849475d6de23",
    "nl": false,
    "rap": false,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 480,
    "wires": [
      [
        "feb0d0729183301f"
      ]
    ]
  },
  {
    "id": "937eee210ea09a90",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Pretty GPS",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 650,
    "y": 480,
    "wires": []
  },
  {
    "id": "e7d0663bcdd44a06",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "d": true,
    "name": "Format Starlink GPS",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1220,
    "y": 100,
    "wires": []
  },
  {
    "id": "e3dff9260e2223fb",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "d": true,
    "name": "Format RUTOS GPS",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1080,
    "y": 400,
    "wires": []
  },
  {
    "id": "df60837fdef6ee90",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Combined",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1730,
    "y": 100,
    "wires": []
  },
  {
    "id": "abaf331e329a7829",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Moved >200m",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1720,
    "y": 320,
    "wires": []
  },
  {
    "id": "96272080f917e69d",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Flush pending",
    "func": "const p = flow.get('pending_gps');\nif (p) node.send({payload: p});",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1100,
    "y": 40,
    "wires": [
      [
        "5d6237d293375110"
      ]
    ]
  },
  {
    "id": "25cedf93982c9bf7",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "IDs learned (patched)",
    "func": "const pl=msg.payload;\nif(pl&&pl.portalId&&pl.deviceInst){global.set('vrm_portal_id',pl.portalId);\nflow.set('gps_device_instance',pl.deviceInst);}\nreturn[ msg, msg ];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 620,
    "y": 40,
    "wires": [
      [
        "3088e0bb7e5c5040"
      ],
      [
        "96272080f917e69d"
      ]
    ]
  },
  {
    "id": "3088e0bb7e5c5040",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "d": true,
    "name": "IDs learned",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "x": 850,
    "y": 20,
    "wires": []
  },
  {
    "id": "5d6237d293375110",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Format Victron MQTT (direct)",
    "func": "var portal = global.get('vrm_portal_id');\nif (!portal) {\n    flow.set('pending_gps', msg.payload);\n    return null;\n}\nflow.set('pending_gps', null);\n\nvar dev = flow.get('gps_device_instance') || '1';\nvar base = 'W/' + portal + '/gps/' + dev;\nvar r = (n, d) => Number.isFinite(n) ? +n.toFixed(d) : n;\n\nvar out = [\n    { topic: base + '/Position/Latitude',  payload: JSON.stringify({ value: r(msg.payload.lat, 6) }) },\n    { topic: base + '/Position/Longitude', payload: JSON.stringify({ value: r(msg.payload.lon, 6) }) },\n    { topic: base + '/Altitude',           payload: JSON.stringify({ value: r(msg.payload.alt, 1) }) },\n    { topic: base + '/Speed',              payload: JSON.stringify({ value: r(msg.payload.speed, 2) }) },\n    { topic: base + '/Fix',                payload: JSON.stringify({ value: msg.payload.gpsFix || 0 }) }\n];\n\nif (msg.payload.sats != null)\n    out.push({ topic: base + '/NrOfSatellites', payload: JSON.stringify({ value: msg.payload.sats }) });\n\nif (msg.payload.hAcc != null)\n    out.push({ topic: base + '/Hdop', payload: JSON.stringify({ value: r(msg.payload.hAcc, 1) }) });\n\nout.forEach(node.send);\nreturn null;\n",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1780,
    "y": 40,
    "wires": [
      [
        "5d8fad924d8906d6",
        "bc8b6d8bb03396ce"
      ]
    ]
  },
  {
    "id": "5d8fad924d8906d6",
    "type": "mqtt out",
    "z": "052a8592cc8aee65",
    "name": "Victron MQTT",
    "topic": "",
    "qos": "2",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "2712849475d6de23",
    "x": 2060,
    "y": 40,
    "wires": []
  },
  {
    "id": "bc8b6d8bb03396ce",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "debug MQTT out",
    "active": true,
    "tosidebar": true,
    "console": true,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 2070,
    "y": 100,
    "wires": []
  },
  {
    "id": "cddff0074ff0367a",
    "type": "function",
    "z": "052a8592cc8aee65",
    "name": "Cache & pretty",
    "func": "// tolerate either a raw string or a decoded object\nconst raw = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n\nconst parts  = msg.topic.split('/');\nconst portal = parts[1];\nconst dev    = parts[3];\nconst path   = parts.slice(4).join('/');\n\nconst cache = flow.get('last_position') || {};\nif (path === 'Position/Latitude')  cache.lat   = +raw.value;\nif (path === 'Position/Longitude') cache.lon   = +raw.value;\nif (path === 'Altitude')           cache.alt   = +raw.value;\nif (path === 'Speed')              cache.speed = +raw.value;\ncache.ts = Date.now();\nflow.set('last_position', cache);\n\nmsg.payload = { portalId: portal, deviceInst: dev, path, value: raw.value };\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 460,
    "y": 480,
    "wires": [
      [
        "937eee210ea09a90"
      ]
    ]
  },
  {
    "id": "feb0d0729183301f",
    "type": "json",
    "z": "052a8592cc8aee65",
    "name": "",
    "property": "payload",
    "action": "",
    "pretty": false,
    "x": 290,
    "y": 480,
    "wires": [
      [
        "cddff0074ff0367a"
      ]
    ]
  },
  {
    "id": "bdb24cd84e9befd5",
    "type": "exec",
    "z": "052a8592cc8aee65",
    "command": "/data/bin/grpcurl -plaintext -d {\\\"dish_clear_obstruction_map\\\":{}} 192.168.100.1:9200 SpaceX.API.Device.Device/Handle",
    "addpay": false,
    "append": "",
    "useSpawn": "false",
    "timer": "10",
    "winHide": false,
    "oldrc": false,
    "name": "Reset Obstruction Map",
    "x": 1740,
    "y": 380,
    "wires": [
      [
        "05c0703c81a0c758"
      ],
      [],
      []
    ]
  },
  {
    "id": "05c0703c81a0c758",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Debug Reset Obstruction",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "payload",
    "statusType": "auto",
    "x": 2010,
    "y": 440,
    "wires": []
  },
  {
    "id": "1ab986af44cca762",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "d": true,
    "name": "Debug RUTOS GPS",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "payload",
    "statusType": "auto",
    "x": 800,
    "y": 400,
    "wires": []
  },
  {
    "id": "7a40dacb6ed111fe",
    "type": "debug",
    "z": "052a8592cc8aee65",
    "name": "Combine GPS 2",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1420,
    "y": 260,
    "wires": []
  },
  {
    "id": "2712849475d6de23",
    "type": "mqtt-broker",
    "name": "Cerbo MQTT",
    "broker": "localhost",
    "port": "1883",
    "clientid": "",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "autoUnsubscribe": true,
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "birthMsg": {},
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "closeMsg": {},
    "willTopic": "",
    "willQos": "0",
    "willPayload": "",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  }
]